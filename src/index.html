<!DOCTYPE html>
<html lang="en">
	<head>
		<title>AP3.0 Engine Demo</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link href="css/main.css" rel="stylesheet" />

		<script src="../libs/Detector.js"></script>
		<script src="../libs/stats.min.js"></script>
		<script src="../libs/signals.min.js"></script>
		<script src="../libs/dat.gui.min.js"></script>

		<script src="../libs/three/three.min.js"></script>
		<script src="../libs/three/controls/TrackballControls.js"></script>

		<script src="js/audiopixel.js"></script>
		<script src="js/utils.js"></script>
		<script src="js/managers/AppManager.js"></script>
		<script src="js/managers/PortManager.js"></script>
		<script src="js/managers/HardwareManager.js"></script>
		<script src="js/managers/ChannelManager.js"></script>
		<script src="js/objects/Port.js"></script>
		<script src="js/objects/Channel.js"></script>
		<script src="js/objects/Pod.js"></script>
		<script src="js/objects/Clip.js"></script>
		<script src="js/objects/Shader.js"></script>
		<script src="js/objects/PodPosition.js"></script>

		<script src="import/shaders/core/ShaderUtils.js"></script>
		<script src="import/shaders/core/SimpleTextureShader.js"></script>
		<script src="import/shaders/core/NodeShader.js"></script>


		<script src="import/shaders/clips/SolidColorClip.js"></script>
		<script src="import/shaders/clips/TestFrameClip.js"></script>
		<script src="import/shaders/clips/DiSinSwirlClip.js"></script>
		<script src="import/shaders/clips/ColorSineBarClip.js"></script>
		<script src="import/shaders/clips/ColorSwirlsClip.js"></script>
		<script src="import/shaders/clips/LineCosSinClip.js"></script>
		<script src="import/shaders/clips/SimpleSwirlClip.js"></script>
		<script src="import/shaders/clips/SinSpiralClip.js"></script>
		<script src="import/shaders/clips/SineParticlesClip.js"></script>
		<script src="import/shaders/clips/WaterClip.js"></script>
		<script src="import/shaders/clips/HexifyRadialClip.js"></script>
		<script src="import/shaders/clips/SinCosTanClip.js"></script>
		<script src="import/shaders/clips/HueFxClip.js"></script>
		<script src="import/shaders/clips/TestFxClip.js"></script>

		<script src="import/nodes/test.js"></script>
	</head>

	<body ontouchstart="" onload="onLoad()">

		<div id="container"></div>

		<script>


		if ( ! Detector.webgl ) { Detector.addGetWebGLMessage(); }


		var frameCount = 0;
		var gui = new dat.GUI();
		var updateShader;



		function onLoad(){


			// Register all clips by their id's for easy lookup later
			for (var property in ap.clips) {
				if (ap.clips.hasOwnProperty(property)) {
					ap.register[ap.clips[property].id] = property;
				}
			}


			// ****** Managers ******

			ap.ports = new PortManager();
			ap.hardware = new HardwareManager();
			ap.channels = new ChannelManager();
			ap.app = new AppManager(document.getElementById( 'container' ));
			ap.app.setSize(window.innerWidth, window.innerHeight);

			ap.ports.init();
			ap.hardware.init();
			ap.channels.init();
			ap.app.init();



			// -------Temporary: Create some Channels/Pods/Clips for testing----------

			
			// Let's create some test channels for now (TODO: this should be loaded from current project settings)
			var mix = 1;
			var mix2 = 1;
			var pods = [];

			//pods[3] = new Pod(1, mix, ap.BLEND.Add, [new Clip(2, mix, ap.BLEND.Add), new Clip(5, mix, ap.BLEND.Fx)]);
			//pods[2] = new Pod(3, mix, ap.BLEND.Add, [new Clip(3, mix2, ap.BLEND.Add), new Clip(5, 1, ap.BLEND.Fx)]);
			pods[1] = new Pod(2, mix, ap.BLEND.Add, [new Clip(3, mix, ap.BLEND.Add), new Clip(5, 1, ap.BLEND.Fx)]);
			pods[0] = new Pod(1, mix, ap.BLEND.Add, [new Clip(2, mix2, ap.BLEND.Add), new Clip(5, 1, ap.BLEND.Fx)]);

			ap.channels.setChannel(1, new Channel("TestChannel1", ap.CHANNEL_TYPE_BLEND, mix, ap.BLEND.Add, pods));


			var pods2 = [];
			pods2[0] = new Pod(1, mix, ap.BLEND.Add, [new Clip(16, 1, ap.BLEND.Fx)]);

			ap.channels.setChannel(2, new Channel("Post FX1", ap.CHANNEL_TYPE_FX, mix, ap.BLEND.Add, pods2));

			ap.app.updateNodePoints();
			ap.app.updateMainSourceShader();



			// ****** Runtime Loop ****** 

			var updateShaderLimiter = 0;
			// Allow limiter to be modified based on system capabilities, if we detect lag we can increase it

			function animate() {

				//if(frameCount % 30 == 1){ // Slow framerate testing


				// Update everything else if we don't have to update the shader this frame
				if((!updateShader || updateShaderLimiter < 4) && updateShaderLimiter > 0){

					// ** Main loop update 
					ap.app.update();
					ap.ports.update();
					ap.hardware.update();
					ap.channels.update();

				}else{

					// We detected the shader needs an update, only do that this frame
					ap.app.updateMainSourceShader();
					ap.app.update();
					updateShaderLimiter = 0;
					updateShader = false;
				}
				updateShaderLimiter++;

				// Render next frame // TODO: throttle logic if needed
				requestAnimationFrame( animate );
				frameCount++;
			}

			animate();

			// ****** UI ******

			// TODO replace dat.gui with react components (or similar) that reflect model: ap.channels 



			var guiData  = {
				Channel1Mix:  1,
				/*
				S3Blend:  'Add',
				S3ClipId:  0,
				S3Mix:  1,
				S3Scale:  1,
				Hue3Mix:  1,
				*/
				S2Blend:  'Add',
				S2ClipId:  ap.demoHardware[0],
				S2Mix:  1,
				S2Scale:  .7,
				S2HueTint:  1,

				S1Mix:  1,
				S1ClipId:  ap.demoHardware[0],
				S1Scale:  .7,
				S1HueTint:  1,

				Hue:  1,
				Sat:  1,
				Threshold:  1,
				Noise:  0,

				Speed: ap.app.speed,
				PointSize: 60,
				Hardware: ap.demoHardware[0]

			}
			
			gui.remember(guiData);
			gui.add( guiData, "Channel1Mix", 0.0, 1.0, 1.0 )	.onChange(function () { ap.app.material.uniforms._1_mix.value = guiData.Channel1Mix; });
			

			gui.add( guiData, 'Hardware', ap.demoHardware).onChange(function () {

				ap.ports.clearAllPorts();

				switch(guiData.Hardware){
					case ap.demoHardware[0]:

						ap.channels.setPodPos(2, new PodPosition(-190, 140, 0, 1070, 575, 1));
						ap.hardware.importNodes(ap.imported, 1, 0, 0, 0);
						break;
					case ap.demoHardware[1]:

						ap.channels.setPodPos(2, { x: -340, y: 30, z: 10, w: 1380, h: 740, d: 1 });
						ap.hardware.addTestPortsGrid3(1, 0, 0);
						break;

					case ap.demoHardware[2]:

						ap.channels.setPodPos(2, new PodPosition(-190, 286, 0, 1070, 242, 1));
						ap.hardware.addTestPortsGrid(1, 0, 0);
						break;


					default: 
						ap.hardware.importNodes(ap.imported, 1, 0, 0, 0);
					break;
				}
					ap.app.updateNodePoints(); // only need to call this when we add nodes after init
					ap.app.updateMainSourceShader();

					updateShader = true;

			});

			//var f1 = gui.addFolder('Shader 1'); 		f1.open();
			var f2 = gui.addFolder('Shader 1'); 		f2.open();
			var f3 = gui.addFolder('Shader 2'); 	//	f3.open();
			var f4 = gui.addFolder('Post FX'); 		//	f4.open();
			var f5 = gui.addFolder('Settings'); 	//	f5.open();

			/*
			// Pod 3
			f1.add( guiData, 'S3Blend', ap.BLENDS )		.onChange(function () { uniformBlendChange( guiData.S3Blend, "_1_3"); });
			f1.add( guiData, 'S3ClipId', ap.demoPresetNames).onChange(function () { uniformClipTypeChange( guiData.S3ClipId, 1, 3, 1 ); });
			f1.add( guiData, "S3Mix", 0.0, 1.0, 1.0 )	.onChange(function () { ap.app.material.uniforms._1_3_1_mix.value = guiData.S3Mix; });
			f1.add( guiData, "S3Scale", 0.0, 1.0, 1.0 )	.onChange(function () { ap.app.material.uniforms._1_3_1_p1.value = guiData.S3Scale; });
			f1.add( guiData, "Hue3Mix", 0.0, 1.0, 1.0 )	.onChange(function () { ap.app.material.uniforms._1_3_2_p1.value = guiData.Hue3Mix; });
			*/
			// Pod 2
			f2.add( guiData, 'S2ClipId', ap.demoPresetNames).onChange(function () { uniformClipTypeChange( guiData.S2ClipId, 1, 2, 1 ); });
			f2.add( guiData, "S2Mix", 0.0, 1.0, 1.0 )	.onChange(function () { ap.app.material.uniforms._1_2_1_mix.value = guiData.S2Mix; });
			f2.add( guiData, "S2Scale", 0.0, 1.0, 1.0 )	.onChange(function () { ap.app.material.uniforms._1_2_1_p1.value = guiData.S2Scale; });
			f2.add( guiData, "S2HueTint", 0.0, 1.0, 1.0 )	.onChange(function () { ap.app.material.uniforms._1_2_2_p1.value = guiData.S2HueTint; });
			f2.add( guiData, 'S2Blend', ap.BLENDS )		.onChange(function () { uniformBlendChange( guiData.S2Blend, "_1_2"); });
			
			// Pod 1
			f3.add( guiData, 'S1ClipId', ap.demoPresetNames).onChange(function () { uniformClipTypeChange( guiData.S1ClipId, 1, 1, 1 ); });
			f3.add( guiData, "S1Mix", 0.0, 1.0, 1.0 )	.onChange(function () { ap.app.material.uniforms._1_1_1_mix.value = guiData.S1Mix; });
			f3.add( guiData, "S1Scale", 0.0, 1.0, 1.0 )	.onChange(function () { ap.app.material.uniforms._1_1_1_p1.value = guiData.S1Scale; });
			f3.add( guiData, "S1HueTint", 0.0, 1.0, 1.0 )	.onChange(function () { ap.app.material.uniforms._1_1_2_p1.value = guiData.S1HueTint; });
			
			// Post Fx
			f4.add( guiData, "Hue", 0.0, 1.0, 1.0 )	.onChange(function () { ap.app.material.uniforms._2_1_1_p1.value = guiData.Hue; });
			f4.add( guiData, "Sat", 0.0, 1.0, 1.0 )	.onChange(function () { ap.app.material.uniforms._2_1_1_p2.value = guiData.Sat; });
			f4.add( guiData, "Threshold", 0.0, 1.0, 1.0 ).onChange(function () { ap.app.material.uniforms._2_1_1_p5.value = guiData.Threshold; });
			f4.add( guiData, "Noise", 0.0, 1.0, 1.0 ).onChange(function () { ap.app.material.uniforms._2_1_1_p6.value = guiData.Noise; });
			
			// Global Settings (temporary for demo)
			f5.add( guiData, "Speed", 0.0, .15, 1.0 ).onChange(function () { ap.app.speed = guiData.Speed; });
			f5.add( guiData, "PointSize", 15.0, 90.0, 1.0 ).onChange(function () { ap.app.nodeShaderMaterial.uniforms.u_pointSize.value = guiData.PointSize; });
			
			f5.add( { ResetCam:function(){
				ap.app.controls.reset();
			} } ,'ResetCam');


			// ****** Event Handlers ****** 

			document.addEventListener( 'keydown', function ( event ) {

				//console.log(event.keyCode);

				switch ( event.keyCode ) {

					case 8: // prevent browser back
						event.preventDefault();
						break;


		// TESTING
		/*
					case 46: // delete

						ap.app.pointCloud.parent.remove( ap.app.pointCloud );

						console.log('delete');

						break;

			*/		case 16: // shift
/*
						//ap.app.updateNodePoints(); // only need to call this when we add nodes after init
						//ap.app.updateMainSourceShader();


						//ap.app.addPlanesForTesting(); 

						console.log("doitshift");
						ap.channels.clearAllPodsInChannel(1);
						updateShader = true;

						break;

					case 17: // ctrl

					// lets test changing the clips in a channel at run time
						//var mix = 1;
						//var pods = [new Pod(1, mix, ap.BLEND.Add, [new Clip(1, mix, ap.BLEND.Add), new Clip(2, mix, ap.BLEND.Add)])];
						//var pods = [new Pod(1, mix, ap.BLEND.Add, [new Clip(4, mix, ap.BLEND.Add)])];
						//ap.channels.setChannel(1, new Channel("TestChannel1", ap.CHANNEL_TYPE_BLEND, mix, ap.BLEND.Add, pods));


						//ap.channels.setClip(1, 4, 1, new Clip(1, 1, ap.BLEND.Add));
						//ap.channels.deleteClip(1, 2, 1);
						//ap.channels.deleteAllClipsInPod(1, 2);

						uniformClipTypeChange(1, 1, 2, 1) 

						console.log("doit");
						updateShader = true;

		*/
						break;
				}

			}, false );


			function onWindowResize() {

				// TODO - allow to be set in page and not always use fullscreen of window res
				ap.app.glWidth = window.innerWidth;
				ap.app.glHeight = window.innerHeight;

				if(ap.app.readPixels){
					ap.app.pixels = new Uint8Array(4 * ap.app.glWidth * ap.app.glHeight);
				}

				ap.app.camera.aspect = ap.app.glWidth / ap.app.glHeight;
				ap.app.camera.updateProjectionMatrix();

				ap.app.renderer.setSize( ap.app.glWidth, ap.app.glHeight );

			}

			window.addEventListener( 'resize', onWindowResize, false );

			setTimeout(onWindowResize, 1);

		}

		</script>
	</body>
</html>


<!-- TODO this should be moved to seperate file, but working on it here for building is handy for now-->
<script id="fragment_shader_pass_1" type="x-shader/x-fragment">

//#INCLUDESHADERUTILS

precision mediump float;
float ap_index;
vec4 ap_xyz;
vec4 ap_xyz2;
//vec3  ap_lastRgb;
vec3 ap_rgb;
vec3 ap_hsv;
vec3 ap_rgb2;
vec4 ap_rgbV4;
vec3 ap_c;
vec3 ap_p;
vec2 resolution;

varying vec2 v_vUv;
uniform float u_time;
uniform float u_random;
uniform float u_mapSize;
uniform sampler2D u_coordsMap;
uniform sampler2D u_prevCMap;
//uniform sampler2D u_portsMap;

// Temporary use values
float random;
vec2 p; 
vec3 c;
float cf;
float t;

// TODO optimize this list to only include what we need each regeneration
#define ptpi 1385.4557313670110891409199368797 //powten(pi)
#define pipi  36.462159607207911770990826022692 //pi pied, pi^pi
#define picu  31.006276680299820175476315067101 //pi cubed, pi^3
#define pepi  23.140692632779269005729086367949 //powe(pi);
#define chpi  11.59195327552152062775175205256  //cosh(pi)
#define shpi  11.548739357257748377977334315388 //sinh(pi)
#define pisq  9.8696044010893586188344909998762 //pi squared, pi^2
#define twpi  6.283185307179586476925286766559  //two pi, 2*pi 
#define pi    3.1415926535897932384626433832795 //pi
#define sqpi  1.7724538509055160272981674833411 //square root of pi 
#define hfpi  1.5707963267948966192313216916398 //half pi, 1/pi
#define cupi  1.4645918875615232630201425272638 //cube root of pi
#define prpi  1.4396194958475906883364908049738 //pi root of pi
#define lnpi  1.1447298858494001741434273513531 //logn(pi); 
#define trpi  1.0471975511965977461542144610932 //one third of pi, pi/3
#define thpi  0.99627207622074994426469058001254//tanh(pi)
#define lgpi  0.4971498726941338543512682882909 //log(pi)       
#define rcpi  0.31830988618379067153776752674503// reciprocal of pi  , 1/pi  
#define rcpipi  0.0274256931232981061195562708591 // reciprocal of pipi  , 1/pipi 

//#INCLUDESHADERFUNCTIONS

void main() {

	random = rand(vec2(gl_FragCoord[0], gl_FragCoord[1] * u_random) * (u_time * 0.0001));

	// Black is default
	ap_rgb = vec3(0.0);


	
	//********************************************
	
	ap_xyz = texture2D( u_coordsMap, v_vUv); // coordinates that get overwritten with each pod
	ap_xyz2 = ap_xyz; // coordinates that do not get overwritten (original)
	if(ap_xyz[3] == 0.0){ discard; }

	ap_index = ((1.0 - v_vUv.y) * u_mapSize * u_mapSize + v_vUv.x * u_mapSize);
	//ap_lastRgb = vec3(texture2D( u_prevCMap, v_vUv));

	//********************************************

	//#INCLUDESHADERS

	gl_FragColor = vec4(ap_c, 1.0);

}

</script>