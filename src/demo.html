<!DOCTYPE html>
<html lang="en">
	<head>
		<title>AP3.001</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #333333;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body onload="onLoad()">

		<div id="container"></div>

		<script src="js/libs/three/three.min.js"></script>
		<script src="js/libs/three/controls/TrackballControls.js"></script>
		<script src="js/libs/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src="js/libs/dat.gui.min.js"></script>

		<script id="vertexShader" type="x-shader/x-vertex">

			varying vec2 v_vUv;
			void main() {
				v_vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}
		</script>
		<script id="fragment_screen" type="x-shader/x-fragment">
			varying vec2 v_vUv;
			uniform sampler2D u_colorMap;
			uniform float scale;
			void main() {
				vec4 color = texture2D( u_colorMap, v_vUv );
				if(color[3] == 0.0){ discard; }
				gl_FragColor = color * scale;
			}
		</script>

		<!---------------------------------------------------------------------------------------------- -->
		<!---------------------------------------------------------------------------------------------- -->

		<script id="fragment_shader_pass_1" type="x-shader/x-fragment">



vec3 rgb2hsv(vec3 c)
{
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 hsv2rgb(vec3 c) {
	vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}



vec3 blend(vec3 c1, vec3 c2, float type)
{
	if(type == 1.0){ return c1 + c2; }else					// Add
	if(type == 2.0){ return c1 - c2; }else					// Subtract
	if(type == 3.0){ return min(c1, c2); }else				// Darkest
	if(type == 4.0){ return max(c1, c2); }else				// Lighest
	if(type == 5.0){ return abs(c2 - c1); }else				// DIFFERENCE
	if(type == 6.0){ return c1 + c2 - 2.0 * c1 * c2; }else	// EXCLUSION
	if(type == 7.0){ return c1 * c2; }else					// Multiply
	if(type == 8.0){ return (c1 + c2) - (c1 * c2); }else	// Screen
															// Overlay
	if(type == 9.0){ return vec3((c2.r <= 0.5) ? (2.0 * c1.r * c2.r) : (1.0 - 2.0 * (1.0 - c2.r) * (1.0 - c1.r)),(c2.g <= 0.5) ? (2.0 * c1.g * c2.g) : (1.0 - 2.0 * (1.0 - c2.g) * (1.0 - c1.g)),(c2.b <= 0.5) ? (2.0 * c1.b * c2.b) : (1.0 - 2.0 * (1.0 - c2.b) * (1.0 - c1.b))); }else
															// HARD LIGHT
	if(type == 10.0){ return vec3((c1.r <= 0.5) ? (2.0 * c1.r * c2.r) : (1.0 - 2.0 * (1.0 - c1.r) * (1.0 - c2.r)),(c1.g <= 0.5) ? (2.0 * c1.g * c2.g) : (1.0 - 2.0 * (1.0 - c1.g) * (1.0 - c2.g)),(c1.b <= 0.5) ? (2.0 * c1.b * c2.b) : (1.0 - 2.0 * (1.0 - c1.b) * (1.0 - c2.b))); }else
															// SOFT LIGHT
	if(type == 11.0){ return vec3((c1.r <= 0.5) ? (c2.r - (1.0 - 2.0 * c1.r) * c2.r * (1.0 - c2.r)) : (((c1.r > 0.5) && (c2.r <= 0.25)) ? (c2.r + (2.0 * c1.r - 1.0) * (4.0 * c2.r * (4.0 * c2.r + 1.0) * (c2.r - 1.0) + 7.0 * c2.r)) : (c2.r + (2.0 * c1.r - 1.0) * (sqrt(c2.r) - c2.r))),(c1.g <= 0.5) ? (c2.g - (1.0 - 2.0 * c1.g) * c2.g * (1.0 - c2.g)) : (((c1.g > 0.5) && (c2.g <= 0.25)) ? (c2.g + (2.0 * c1.g - 1.0) * (4.0 * c2.g * (4.0 * c2.g + 1.0) * (c2.g - 1.0) + 7.0 * c2.g)) : (c2.g + (2.0 * c1.g - 1.0) * (sqrt(c2.g) - c2.g))),(c1.b <= 0.5) ? (c2.b - (1.0 - 2.0 * c1.b) * c2.b * (1.0 - c2.b)) : (((c1.b > 0.5) && (c2.b <= 0.25)) ? (c2.b + (2.0 * c1.b - 1.0) * (4.0 * c2.b * (4.0 * c2.b + 1.0) * (c2.b - 1.0) + 7.0 * c2.b)) : (c2.b + (2.0 * c1.b - 1.0) * (sqrt(c2.b) - c2.b)))); }else
															// DODGE
	if(type == 12.0){ return vec3((c1.r == 1.0) ? 1.0 : min(1.0, c2.r / (1.0 - c1.r)),(c1.g == 1.0) ? 1.0 : min(1.0, c2.g / (1.0 - c1.g)),(c1.b == 1.0) ? 1.0 : min(1.0, c2.b / (1.0 - c1.b))); }else
															// Burn
	if(type == 13.0){ return vec3((c1.r == 0.0) ? 0.0 : (1.0 - ((1.0 - c2.r) / c1.r)),(c1.g == 0.0) ? 0.0 : (1.0 - ((1.0 - c2.g) / c1.g)), (c1.b == 0.0) ? 0.0 : (1.0 - ((1.0 - c2.b) / c1.b))); }else
	if(type == 14.0){ return (c1 + c2) - 1.0; }else			// LINEAR BURN
	if(type == 15.0){ return 2.0 * c1 + c2 - 1.0; }else		// LINEAR LIGHT		
															// VIVID LIGHT
	if(type == 16.0){ return vec3((c1.r <= 0.5) ? (1.0 - (1.0 - c2.r) / (2.0 * c1.r)) : (c2.r / (2.0 * (1.0 - c1.r))),(c1.g <= 0.5) ? (1.0 - (1.0 - c2.g) / (2.0 * c1.g)) : (c2.g / (2.0 * (1.0 - c1.g))),(c1.b <= 0.5) ? (1.0 - (1.0 - c2.b) / (2.0 * c1.b)) : (c2.b / (2.0 * (1.0 - c1.b)))); }else
															// PIN LIGHT
	if(type == 17.0){ return vec3((c1.r > 0.5) ? max(c2.r, 2.0 * (c1.r - 0.5)) : min(c2.r, 2.0 * c1.r), (c1.r > 0.5) ? max(c2.g, 2.0 * (c1.g - 0.5)) : min(c2.g, 2.0 * c1.g),(c1.b > 0.5) ? max(c2.b, 2.0 * (c1.b - 0.5)) : min(c2.b, 2.0 * c1.b)); }else
	{ return c1 + c2; }										// Add (default)
}

/////////////////////////////
float rand(vec2 co)
{
    highp float a = 12.9898;
    highp float b = 78.233;
    highp float c = 43758.5453;
    highp float dt= dot(co.xy ,vec2(a,b));
    highp float sn= mod(dt,3.14);
    return fract(sin(sn) * c);
}

float mixT(float a, float b, float mix){
	return ((a*(mix)+b*mix));
}

//----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/-
//---/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/--
//--/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/---
//-/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----
///----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/----/

			precision mediump float;
			float ap_index;
			vec4  ap_xyz;
			vec3  ap_lastRgb;
			vec3  ap_rgb;

			varying vec2 v_vUv;
			uniform float u_time;
			uniform float u_random;
			uniform float u_mapSize;
			uniform sampler2D u_coordsMap;
			uniform sampler2D u_prevCMap;
			uniform sampler2D u_portsMap;

			//-----------------------------------------

			uniform float u_blend;
			uniform float u_direction;

			uniform float u_mix1;
			uniform float u_hue1;
			uniform float u_scale1;

			uniform float u_mix2;
			uniform float u_hue2;
			uniform float u_scale2;

			uniform float u_smooth;
			uniform float u_hue;
			uniform float u_saturation;
			uniform float u_thresholdMin;
			uniform float u_thresholdMax;
			uniform float u_wsparkle;
			uniform float u_wshue;

			//-----------------------------------------


			void main(void) {

				//********************************************
				ap_xyz = texture2D( u_coordsMap, v_vUv);
				if(ap_xyz[3] == 0.0){ discard; }

				ap_index = ((1.0 - v_vUv.y) * u_mapSize * u_mapSize + v_vUv.x * u_mapSize);
				ap_lastRgb = vec3(texture2D( u_prevCMap, v_vUv));

				//********************************************

				float random = rand(vec2(gl_FragCoord[0], gl_FragCoord[1] * u_random) * (u_time * 0.0001));
				//float random = rand(vec2(gl_FragCoord[1], v_vUv[0] * u_random) * (u_time * 0.001));
				//float random = rand(vec2(gl_FragCoord[0], v_vUv[1] * u_random) * (u_time * 0.0001));


				//--------------------------------
				// Water bend

				vec2 p = (((u_scale1 * 110000.) + 10000.) * vec2( ap_xyz[0] +  (ap_xyz[2] * 0.25), ap_xyz[1]) ) + 6.;

				float x = p.x;
				float y = p.y;
				float mov0 = x+y+cos(sin(u_time)*2.0)*100.+sin(x/100.)*1000.;
				float mov1 = y;
				float mov2 = x;
				float c1 = abs(sin(mov1+u_time)/2.+mov2/2.-mov1-mov2+u_time);
				float c2 = abs(sin(c1+sin(mov0/1000.+u_time)+sin(y/40.+u_time)+sin((x+y)/100.)*3.));
				float c3 = abs(sin(c2+cos(mov1+mov2+c2)+cos(mov2)+sin(x/1000.)));

				c1 = c1 * 0.25;

				ap_rgb.r = 1.0;
				ap_rgb.g = 1.0;
				ap_rgb.b = 1.0;
				ap_rgb = vec3(c2,c3,c1) * u_mix1;  // mix


				vec3 hsl = rgb2hsv(ap_rgb); // hue knob
				hsl[0] += u_hue1;
				if(hsl[0] > 1.0){ hsl[0] =  hsl[0] - floor(hsl[0]); }

				ap_rgb = hsv2rgb(hsl); // output
				//ap_rgb = vec3(random) * u_mix1; // output

				//-----------------------------------------
				// Cross hatch

				float rtime = abs(u_time);
				p = (((u_scale2 * 18000.0) + 500.0) * vec2( ap_xyz[0], ap_xyz[2]) - ap_xyz[1] * fract(rtime*0.00007));
				p[0] += 0.1;
				vec2 q = vec2( cos(p.x), sin(p.y) );
				rtime = rtime + q.x * q.y + length( q );
				vec3 c = vec3( 0.0 );
				c += vec3(2.0, 2.5, 1.0) * fract( (              p.x - p.y + fract(rtime*0.0017) ) * 5.0 ) ;
				c -= vec3(1.0, 2.0, 2.3) * fract( (sin(u_time*0.25)*p.x - p.y + fract(rtime*0.0015) ) * 5.0 ) ;
				c += ( p.x * p.y );

				c = max(c, vec3(0.0));
				c = min(c, vec3(1.0));
				vec3 rgb_2 = c * u_mix2; // mix

				hsl = rgb2hsv(rgb_2); // hue knob
				hsl[0] += u_hue2;
				if(hsl[0] > 1.0){ hsl[0] =  hsl[0] - floor(hsl[0]); }

				rgb_2 = hsv2rgb(hsl); // output
				//rgb_2 = vec3(1.0) * u_mix2; // output

				//-----------------------------------------
				// Blend Mix

				if(u_direction > 0.0){
					vec3 swap = (rgb_2);
					rgb_2 = (ap_rgb);
					ap_rgb = (swap);
				}
				
				ap_rgb = blend(ap_rgb, rgb_2, u_blend);

				//-----------------------------------------
				// Post FX

 				// hue knob
				hsl = rgb2hsv(ap_rgb);

				// saturation
				hsl[1] = hsl[1] * u_saturation;

				// thresholds
				float tt = u_thresholdMax;
				if(tt == 1.0){tt = 0.0;}
				if(hsl[0] > 1.0){ hsl[0] =  hsl[0] - floor(hsl[0]); }
				if(tt > u_thresholdMin && (hsl[2] > tt || hsl[2] < u_thresholdMin)){
					discard;
				}

				// whitesparkle
				float target = hsl[0] + u_wshue;
				if(target > 1.0){ target =  target- floor(target); }
				if(target < 0.05){
					if(random > (0.8 + ((1.0 - u_wsparkle) * 0.3) )){
						hsl[2] = 1.0;
					}
				}
				hsl[0] += u_hue;
				if(hsl[0] > 1.0){ hsl[0] =  hsl[0] - floor(hsl[0]); }


				ap_rgb = hsv2rgb(hsl);

				// smooth
				// ap_rgb = blend(ap_rgb, ap_lastRgb, 1.0) * u_smooth;

				// bDif = Utils.mix(lastB, b, _mix);

				// ((a*(mix)+b*mix));

				//ap_rgb.r = mixT(ap_rgb.r, ap_lastRgb.r, u_smooth );
				//ap_rgb.g = mixT(ap_rgb.g, ap_lastRgb.g, u_smooth );
				//ap_rgb.b = mixT(ap_rgb.b, ap_lastRgb.b, u_smooth );


				//-----------------------------------------
				// Output


				//ap_rgb = min(ap_rgb, vec3(0.8));
				//rgb_2 = min(rgb_2, vec3(0.8));

				//mainmix = min(mainmix, vec3(0.8));

				gl_FragColor = vec4(ap_rgb, 1.0);
			}

		</script>
		<!---------------------------------------------------------------------------------------------- -->
		<!---------------------------------------------------------------------------------------------- -->
		<script type="x-shader/x-vertex" id="node_vertexshader">
			uniform float u_pointSize;
			attribute float a_geoX;
			attribute float a_geoY;
			attribute float a_index;
			varying float v_geoX;
			varying float v_geoY;
			varying float v_index;

			void main() {
				v_geoX = a_geoX;
				v_geoY = a_geoY;
				v_index = a_index;

				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_PointSize = u_pointSize * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;
			}

		</script>

		<script type="x-shader/x-fragment" id="node_fragmentshader">

			uniform sampler2D u_colorMap;
			uniform sampler2D u_texture;

			varying float v_geoX;
			varying float v_geoY;
			varying float v_index;

			void main() {

				//float u_imageSize = simSize.0; // TODO turn into constant
				//float index = (v_index) + 1.0;
				//float x = mod(index, u_imageSize);
				//if(x == 0.0){ x = u_imageSize; }
				//float y = (index - x) / u_imageSize;

				//gl_FragColor = texture2D( u_colorMap, vec2( x / u_imageSize, 1.0 - y / u_imageSize ));


				gl_FragColor = texture2D( u_colorMap, vec2( v_geoX, v_geoY )) * texture2D( u_texture, gl_PointCoord);


				//gl_FragColor = vec4(1.0, 0,0,1.0);
				//gl_FragColor = vec4(v_index * 0.0015, 0,0,1.0);
				//gl_FragColor = vec4(v_geoX, v_geoY,0,1.0);

				//gl_FragColor = texture2D( u_colorMap, gl_PointCoord );
			}
		</script>
		<!---------------------------------------------------------------------------------------------- -->
		<!---------------------------------------------------------------------------------------------- -->
		<!---------------------------------------------------------------------------------------------- -->
		<!---------------------------------------------------------------------------------------------- -->
		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;

			var cameraRTT, camera, sceneRTT, scene, renderer, zmesh1, zmesh2;

			var mouseX = 0, mouseY = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			var rtTextureA, rtTextureB, coordsMap, portsMap;
			var rtToggle = true;
			var material, quad, geometry, geoX, geoY;
			var passIndex = [];
			var gl, pixels;
			var gui;

			var delta = 0.02;

			var simSize = 0;
	        var base = 10000000;

			var nodeShaderMaterial;

			var string2x8 = "61,-194,61,-205,61,-216,50,-194,50,-205,50,-216,39,-194,39,-205,39,-216,61,-155,61,-166,61,-177,50,-155,50,-166,50,-177,39,-155,39,-166,39,-177,61,-116,61,-127,61,-138,50,-116,50,-127,50,-138,39,-116,39,-127,39,-138,61,-76,61,-88,61,-99,50,-76,50,-88,50,-99,39,-76,39,-88,39,-99,61,-37,61,-48,61,-60,50,-37,50,-48,50,-60,39,-37,39,-48,39,-60,61,2,61,-9,61,-20,50,2,50,-9,50,-20,39,2,39,-9,39,-20,61,41,61,30,61,19,50,41,50,30,50,19,39,41,39,30,39,19,61,80,61,69,61,58,50,80,50,69,50,58,39,80,39,69,39,58,22,-194,22,-205,22,-216,11,-194,11,-205,11,-216,0,-194,0,-205,0,-216,22,-155,22,-166,22,-177,11,-155,11,-166,11,-177,0,-155,0,-166,0,-177,22,-116,22,-127,22,-138,11,-116,11,-127,11,-138,0,-116,0,-127,0,-138,22,-76,22,-88,22,-99,11,-76,11,-88,11,-99,0,-76,0,-88,0,-99,22,-37,22,-48,22,-60,11,-37,11,-48,11,-60,0,-37,0,-48,0,-60,22,2,22,-9,22,-20,11,2,11,-9,11,-20,0,2,0,-9,0,-20,22,41,22,30,22,19,11,41,11,30,11,19,0,41,0,30,0,19,22,80,22,69,22,58,11,80,11,69,11,58,0,80,0,69,0,58";
			var data2x8 = string2x8.split(',');

			//-------------------
			document.addEventListener( 'mousedown', onDocumentMouseDown, false );

			function init() {

				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 1700;
				//camera.position.y = 700;

				cameraRTT = new THREE.OrthographicCamera( simSize / - 2, simSize / 2, simSize / 2, simSize / - 2, -10000, 10000 );
				
				scene = new THREE.Scene();
				sceneRTT = new THREE.Scene();

				rtTextureA = new THREE.WebGLRenderTarget( simSize, simSize, {minFilter: THREE.NearestMipMapNearestFilter,magFilter: THREE.NearestFilter,format: THREE.RGBFormat});
				rtTextureB = rtTextureA.clone();

				//---------------------------

				material = new THREE.ShaderMaterial( {
					uniforms: {
						u_time: { type: "f", value: 0.0 },
						u_prevCMap: { type: "t", value: rtTextureB },
						u_coordsMap: { type: "t", value: coordsMap },
						u_portsMap: { type: "t", value: portsMap },
						u_random: { type: "f", value: Math.random() },
						u_mapSize: { type: "f", value: simSize },
						u_blend:        { type: 'f', value: 2.0 },
						u_direction:        { type: 'f', value: 0.0 },
						u_mix1:        { type: 'f', value: 1.0 },
						u_hue1:        { type: 'f', value: 0.0 },
						u_scale1:        { type: 'f', value: 0.5 },
						u_mix2:        { type: 'f', value: 1.0 },
						u_hue2:        { type: 'f', value: 0.0 },
						u_scale2:        { type: 'f', value: 0.5 },
						u_smooth:        { type: 'f', value: 0.0 },
						u_hue:        { type: 'f', value: 0.0 },
						u_saturation:        { type: 'f', value: 1.0 },
						u_thresholdMin:        { type: 'f', value: 0.0 },
						u_thresholdMax:        { type: 'f', value: 1.0 },
						u_wsparkle:        { type: 'f', value: 0.0 },
						u_wshue:        { type: 'f', value: 0.0 }
					},
					vertexShader: document.getElementById( 'vertexShader' ).textContent,
					fragmentShader: document.getElementById( 'fragment_shader_pass_1' ).textContent

				} );

				quad = new THREE.Mesh( new THREE.PlaneGeometry( simSize, simSize), material );
				quad.position.z = -100;
				sceneRTT.add( quad );

				//-------------------------------------
				//------------- preview planes

				//--------
				// preview rtTextureA
				var materialScreen = new THREE.ShaderMaterial( {
					uniforms: { u_colorMap: { type: "t", value: rtTextureA }, scale: { type: "f", value: 1.0 } },
					vertexShader: document.getElementById( 'vertexShader' ).textContent,
					fragmentShader: document.getElementById( 'fragment_screen' ).textContent
				} );

				var scale = 1;
				quad = new THREE.Mesh( new THREE.PlaneGeometry( simSize * scale, simSize * scale ), materialScreen );
				quad.position.set(-140, 80, 0);
				scene.add( quad );

				//--------
				// preview rtTextureB

				materialScreen = new THREE.ShaderMaterial( {
					uniforms: { u_colorMap: { type: "t", value: rtTextureB }, scale: { type: "f", value: 1.0 } },
					vertexShader: document.getElementById( 'vertexShader' ).textContent,
					fragmentShader: document.getElementById( 'fragment_screen' ).textContent
				} );

				materialScreen.uniforms.u_colorMap.value = rtTextureB;

				var scale = 1;
				quad = new THREE.Mesh( new THREE.PlaneGeometry( simSize * scale, simSize * scale ), materialScreen );
				quad.position.set(-140, -180, 1);
				scene.add( quad );

				//--------
				// preview coordsMap

				materialScreen = new THREE.ShaderMaterial( {
					uniforms: { u_colorMap: { type: "t", value: coordsMap }, scale: { type: "f", value: 10000.0 } },
					vertexShader: document.getElementById( 'vertexShader' ).textContent,
					fragmentShader: document.getElementById( 'fragment_screen' ).textContent
				} );

				quad = new THREE.Mesh( new THREE.PlaneGeometry( simSize * scale, simSize * scale ), materialScreen );
				quad.position.set(-400, 80, 0);
				scene.add( quad );

				//--------
				// preview portsMap

				materialScreen = new THREE.ShaderMaterial( {
					uniforms: { u_colorMap: { type: "t", value: portsMap }, scale: { type: "f", value: 100.0 } },
					vertexShader: document.getElementById( 'vertexShader' ).textContent,
					fragmentShader: document.getElementById( 'fragment_screen' ).textContent
				} );

				quad = new THREE.Mesh( new THREE.PlaneGeometry( simSize * scale, simSize * scale ), materialScreen );
				quad.position.set(-660, 80, 0);
				scene.add( quad );

				//---------------------------
				
				var attributes = {
					a_geoX:        { type: 'f', value: geoX },
					a_geoY:        { type: 'f', value: geoY },
					a_index:        { type: 'f', value: passIndex }
				};

				uniforms = {
					u_colorMap:   { type: "t", value: rtTextureA },
					u_pointSize:        { type: 'f', value: 60.0 },
					u_texture:   { type: "t", value: THREE.ImageUtils.loadTexture( "images/nodeflare1.png" ) }
				};

				nodeShaderMaterial = new THREE.ShaderMaterial( {

					uniforms:       uniforms,
					attributes:     attributes,
					vertexShader:   document.getElementById( 'node_vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'node_fragmentshader' ).textContent,

					depthTest:      false,
					transparent:    true

				});
				particleSystem = new THREE.PointCloud( geometry, nodeShaderMaterial );
				particleSystem.sortParticles = true;
				scene.add( particleSystem );

				//---------------------------

				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.autoClear = false;

				container.appendChild( renderer.domElement );

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				document.addEventListener( 'mousemove', onDocumentMouseMove, false );

				controls = new THREE.TrackballControls( camera, renderer.domElement);


				//---------------------------------
				// GUI

				var f1 = gui.addFolder('Blend'); 		f1.open();
				var f2 = gui.addFolder('Channel 1'); 	f2.open();
				var f3 = gui.addFolder('Channel 2'); 	f3.open();
				var f4 = gui.addFolder('Post FX'); 		f4.open();
				var f5 = gui.addFolder('Settings'); 	f5.open();
				var guiData  = {
					mix1:  1,
					hue1:  0.6,
					scale1:  0.63,
					mix2:  1,
					hue2:  0.6,
					scale2:  0.28,
					type:  'Substract',
					reverseDirection: false,
					smooth: 0,
					hue: 0,
					saturation: 1,
					thresholdMin: 0.0,
					thresholdMax: 1.0,
					whiteSparkle: 0,
					whiteSHue: 0,
					pointSize: 60,
					speed: delta
				}

				//-Blend
				f1.add(guiData, 'type', [ 'Add', 'Substract', 'Darkest', 'Lightest', 'Difference', 'Exclusion', 'Multiply', 'Screen', 'Overlay', 'HardLight', 'SoftLight', 'Dodge', 'Burn', 'LinearBurn', 'LinearLight', 'VividLight', 'PinLight'] ).onChange(function () { 

					if(guiData.type === 		"Add"){ 				material.uniforms.u_blend.value = 1.0;
					}else if(guiData.type === 	"Substract"){ 			material.uniforms.u_blend.value = 2.0; 
					}else if(guiData.type === 	"Darkest"){ 			material.uniforms.u_blend.value = 3.0; 
					}else if(guiData.type === 	"Lightest"){ 			material.uniforms.u_blend.value = 4.0; 
					}else if(guiData.type === 	"Difference"){ 			material.uniforms.u_blend.value = 5.0;
					}else if(guiData.type === 	"Exclusion"){ 			material.uniforms.u_blend.value = 6.0;
					}else if(guiData.type === 	"Multiply"){ 			material.uniforms.u_blend.value = 7.0; 
					}else if(guiData.type === 	"Screen"){ 				material.uniforms.u_blend.value = 8.0;
					}else if(guiData.type === 	"Overlay"){ 			material.uniforms.u_blend.value = 9.0;
					}else if(guiData.type === 	"HardLight"){ 			material.uniforms.u_blend.value = 10.0;
					}else if(guiData.type === 	"SoftLight"){ 			material.uniforms.u_blend.value = 11.0;
					}else if(guiData.type === 	"Dodge"){ 				material.uniforms.u_blend.value = 12.0;
					}else if(guiData.type === 	"Burn"){ 				material.uniforms.u_blend.value = 13.0;
					}else if(guiData.type === 	"LinearBurn"){ 			material.uniforms.u_blend.value = 14.0;
					}else if(guiData.type === 	"LinearLight"){ 		material.uniforms.u_blend.value = 15.0;
					}else if(guiData.type === 	"VividLight"){ 			material.uniforms.u_blend.value = 16.0;
					}else if(guiData.type === 	"PinLight"){ 			material.uniforms.u_blend.value = 17.0;
					}
				});

				f1.add(guiData, 'reverseDirection', false).onChange(function () { 
					if(guiData.reverseDirection){ 		material.uniforms.u_direction.value  = 1.0;
					}else{ 								material.uniforms.u_direction.value  = 0.0; } });

				//-Channel 1
				f2.add( guiData, "mix1", 0.0, 1.0, 1.0 ).onChange(function () {material.uniforms.u_mix1.value = guiData.mix1;});
				f2.add( guiData, "scale1", 0.0, 1.0, 1.0 ).onChange(function () {material.uniforms.u_scale1.value = guiData.scale1;});
				f2.add( guiData, "hue1", 0.0, 1.0, 1.0 ).onChange(function () {material.uniforms.u_hue1.value = guiData.hue1;});

				//-Channel 2
				f3.add( guiData, "mix2", 0.0, 1.0, 1.0 ).onChange(function () {material.uniforms.u_mix2.value = guiData.mix2;});
				f3.add( guiData, "scale2", 0.0, 1.0, 1.0 ).onChange(function () {material.uniforms.u_scale2.value = guiData.scale2;});
				f3.add( guiData, "hue2", 0.0, 1.0, 1.0 ).onChange(function () {material.uniforms.u_hue2.value = guiData.hue2;});

				//-Post FX
				f4.add( guiData, "saturation", 0.0, 1.0, 1.0 ).onChange(function () {material.uniforms.u_saturation.value = guiData.saturation;});
				f4.add( guiData, "thresholdMin", 0.0, 1.0, 1.0 ).onChange(function () {material.uniforms.u_thresholdMin.value = guiData.thresholdMin;});
				f4.add( guiData, "thresholdMax", 0.0, 1.0, 1.0 ).onChange(function () {material.uniforms.u_thresholdMax.value = guiData.thresholdMax;});
				f4.add( guiData, "whiteSparkle", 0.0, 1.0, 1.0 ).onChange(function () {material.uniforms.u_wsparkle.value = guiData.whiteSparkle;});
				f4.add( guiData, "whiteSHue", 0.0, 1.0, 1.0 ).onChange(function () {material.uniforms.u_wshue.value = guiData.whiteSHue;});
				f4.add( guiData, "hue", 0.0, 1.0, 1.0 ).onChange(function () {material.uniforms.u_hue.value = guiData.hue;});
				f4.add( guiData, "smooth", 0.0, 1.1, 0.1 ).onChange(function () {material.uniforms.u_smooth.value = guiData.smooth;});

				//-Settings
				f5.add( guiData, "pointSize", 20.0, 100.0, 0.1 ).onChange(function () {nodeShaderMaterial.uniforms.u_pointSize.value = guiData.pointSize;});
				f5.add( guiData, "speed", 0.002, 0.05, 0.01 ).onChange(function () {delta = guiData.speed;});

				//-----------------


				// TODO: We'll need this later when we want to #broadcast
					//gl = renderer.getContext(); // Three.js
					//pixels = new Uint8Array(window.innerWidth*window.innerHeight*4); 
			}

		//<!---------------------------------------------------------------------------------------------- -->
		//<!---------------------------------------------------------------------------------------------- -->
		
			function drawNodePoints() {
				geometry = new THREE.Geometry();
				geoX = [];
				geoY = [];
				passIndex = [];

				var setOffsetX = 0;
				var setOffsetY = 0;
				var random = 0; //Math.random() * 90;
				for ( e = 0; e < 170 + random; e ++ ) {
					for ( i = 0; i < 144; i ++ ) { // ap 2x8 hardware unit, 72x2ports = 144 nodes

						var vertex = new THREE.Vector3();
						var scale = 0.4;

						vertex.x = (data2x8[i * 2] * scale) + setOffsetX ;
						vertex.y = ((Math.floor(data2x8[(i * 2) + 1]) + 216) * scale) + setOffsetY + 100; // (-216 lowest int, only want positives)

						vertex.z = Math.random() * (e * 2.25);

						geometry.vertices.push( vertex );
					}
					setOffsetX += 40;

					if(setOffsetX > 650){
						setOffsetX = 0;
						setOffsetY -= 130;
					}
				}

				// TODO: once we know how many nodes we have, we create the lowest power of two texture that can contain all the data
				// 	increase this if you add more nodes
	        	simSize = lowestPowerOfTwo(228);

				console.log("-- nodes: "  + geometry.vertices.length); // #logging
				console.log("-- 2x8s: "  + geometry.vertices.length / 144);
	        	console.log("-- simSize: " + simSize + "x" + simSize);

				for ( i = 1; i <= geometry.vertices.length; i ++ ) {
					// for each point push along x, y values to reference correct pixel in u_colorMaps
					var imageSize = simSize; // TODO turn into constant
					var tx = (i) % imageSize;
					if(tx == 0){
						tx = imageSize;
					}
					var ty = ((i+1) - tx) / imageSize;

					geoX.push(tx / imageSize - 0.5 / imageSize);
					geoY.push(1.0 - ty / imageSize - 0.5 / imageSize); // flip y
					passIndex.push(i-1);
				}
			}

			// ------------

			function generatePortsMap() {

				var a = new Float32Array( Math.pow(simSize, 2) * 4 );
	            var t = 0;

				for ( var k = 0, kl = a.length; k < kl; k += 4 ) {
					var r = 0;
					var g = 0;
					var b = 0;

					if(geometry.vertices[t]){
						// random data for now
	                    r = t / base; // portId and portNodeId 999x9999
	                    g = Math.random() * 10000 / base; // groupId
	                    b = (t * 3) / base;; // hardwareType
						a[ k + 3 ] = 1;
	                }else{
						a[ k + 3 ] = 0;
	                }

                    a[ k + 0 ] = r;
                    a[ k + 1 ] = g;
                    a[ k + 2 ] = b;
					t++;
				}

				portsMap = new THREE.DataTexture( a, simSize, simSize, THREE.RGBAFormat, THREE.FloatType );
				portsMap.minFilter = THREE.NearestFilter;
				portsMap.magFilter = THREE.NearestFilter;
				portsMap.needsUpdate = true;
				portsMap.flipY = true;
			}

			function generateCoordsMap() {

	            var a = new Float32Array( Math.pow(simSize, 2) * 4 );
	            var t = 0;

				for ( var k = 0, kl = a.length; k < kl; k += 4 ) {
					var x = 0;
					var y = 0;
					var z = 0;

					if(geometry.vertices[t]){
	                    x = geometry.vertices[t].x / base;
	                    y = geometry.vertices[t].y / base;
	                    z = geometry.vertices[t].z / base;
						a[ k + 3 ] = 1;
	                }else{
						a[ k + 3 ] = 0;
	                }

                    a[ k + 0 ] = x;
                    a[ k + 1 ] = y;
                    a[ k + 2 ] = z;
					t++;
				}

				coordsMap = new THREE.DataTexture( a, simSize, simSize, THREE.RGBAFormat, THREE.FloatType );
				coordsMap.minFilter = THREE.NearestFilter;
				coordsMap.magFilter = THREE.NearestFilter;
				coordsMap.needsUpdate = true;
				coordsMap.flipY = true;
			}

			// ----------------------

			var tick = 0;
			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

				tick++;
			}

			function render() {

				//camera.position.x += ( mouseX - camera.position.x ) * 0.05;
				//camera.position.y += ( - mouseY - camera.position.y ) * 0.05;
				//camera.lookAt( scene.position );

				controls.update();



				if ( material.uniforms.u_time.value > 18 || material.uniforms.u_time.value < 0 ) {

					delta *= -1;

				}

				//
				material.uniforms.u_time.value += delta;


				// Render first scene into texture
				if(rtToggle){
					material.uniforms.u_prevCMap.value = rtTextureB;
					renderer.render( sceneRTT, cameraRTT, rtTextureA, true );
					nodeShaderMaterial.uniforms.u_colorMap.value = rtTextureA;
				}else{
					material.uniforms.u_prevCMap.value = rtTextureA;
					renderer.render( sceneRTT, cameraRTT, rtTextureB, true );
					nodeShaderMaterial.uniforms.u_colorMap.value = rtTextureB;
				}
				material.uniforms.u_random.value = Math.random();
				rtToggle = !rtToggle;
				renderer.render( scene, camera );


				// We'll need this later when we want to #broadcast
					//gl = renderer.getContext();
					//gl.readPixels(0, 0, 12, 12, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
					//renderer.clear();


				//if(tick % 22 == 1){

				//}
			}

			//********************************************

			var loaded = false;
	        function onLoad() {
	        	loaded = true;
	        }

			function onDocumentMouseDown( event ) { if( loaded && container === undefined){ launch(); } } // main start point once loaded
			function onDocumentMouseMove( event ) {
				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfY;
			}
			//********************************************

	        function launch() {
	        	drawNodePoints();

	        	generateCoordsMap();
	        	generatePortsMap();


				gui = new dat.GUI();
				//gui.close();

				init();
				animate();
	        }

			//********************************************
			//******* Utils

	        function lowestPowerOfTwo(x) {
	        	return Math.pow(2, Math.ceil(Math.log(x)/Math.log(2)));
	        }
	    </script>
	</body>
</html>
