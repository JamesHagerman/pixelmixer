<!DOCTYPE html>
<html lang="en">
	<head>
		<title>AP3.001</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #333333;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body onload="onLoad()">

		<div id="container"></div>

		<script src="js/libs/three/three.min.js"></script>
		<script src="js/libs/three/controls/TrackballControls.js"></script>
		<script src="js/libs/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>
		<script src="js/libs/dat.gui.min.js"></script>

		<!---------------------------------------------------------------------------------------------- -->

		<script>var AP = AP || {};</script>
		<script src="js/shaders/src/basic.js"></script>
		<script src="js/shaders/src/shaderutils.js"></script>

		<script id="vertexShader" type="x-shader/x-vertex">

			varying vec2 v_vUv;
			void main() {
				v_vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}
		</script>
		<script id="fragment_screen" type="x-shader/x-fragment">
			varying vec2 v_vUv;
			uniform sampler2D u_colorMap;
			uniform float scale;
			void main() {
				vec4 color = texture2D( u_colorMap, v_vUv );
				if(color[3] == 0.0){ discard; }
				gl_FragColor = color * scale;
			}
		</script>

		<!---------------------------------------------------------------------------------------------- -->

		<script id="fragment_shader_pass_1" type="x-shader/x-fragment">


			//#INCLUDESHADERUTILS

			precision mediump float;
			float ap_index;
			vec4  ap_xyz;
			vec3  ap_lastRgb;
			vec3  ap_rgb;

			varying vec2 v_vUv;
			uniform float u_time;
			uniform float u_random;
			uniform float u_mapSize;
			uniform sampler2D u_coordsMap;
			uniform sampler2D u_prevCMap;
			uniform sampler2D u_portsMap;

			//-----------------------------------------

			uniform float u_blend;
			uniform float u_direction;

			uniform float u_mix1;
			uniform float u_hue1;
			uniform float u_scale1;

			uniform float u_mix2;
			uniform float u_hue2;
			uniform float u_scale2;

			uniform float u_smooth;
			uniform float u_hue;
			uniform float u_saturation;
			uniform float u_thresholdMin;
			uniform float u_thresholdMax;
			uniform float u_wsparkle;
			uniform float u_wshue;

			//-----------------------------------------


			void main(void) {

				//********************************************
				ap_xyz = texture2D( u_coordsMap, v_vUv);
				if(ap_xyz[3] == 0.0){ discard; }

				ap_index = ((1.0 - v_vUv.y) * u_mapSize * u_mapSize + v_vUv.x * u_mapSize);
				ap_lastRgb = vec3(texture2D( u_prevCMap, v_vUv));

				//********************************************

				float random = rand(vec2(gl_FragCoord[0], gl_FragCoord[1] * u_random) * (u_time * 0.0001));
				//float random = rand(vec2(gl_FragCoord[1], v_vUv[0] * u_random) * (u_time * 0.001));
				//float random = rand(vec2(gl_FragCoord[0], v_vUv[1] * u_random) * (u_time * 0.0001));

				//--------------------------------
				// Water bend

				vec2 p = (((u_scale1 * 110000.) + 10000.) * vec2( ap_xyz[0] +  (ap_xyz[2] * 0.25), ap_xyz[1]) ) + 6.;

				float x = p.x;
				float y = p.y;
				float mov0 = x+y+cos(sin(u_time)*2.0)*100.+sin(x/100.)*1000.;
				float mov1 = y;
				float mov2 = x;
				float c1 = abs(sin(mov1+u_time)/2.+mov2/2.-mov1-mov2+u_time);
				float c2 = abs(sin(c1+sin(mov0/1000.+u_time)+sin(y/40.+u_time)+sin((x+y)/100.)*3.));
				float c3 = abs(sin(c2+cos(mov1+mov2+c2)+cos(mov2)+sin(x/1000.)));

				c1 = c1 * 0.25;

				ap_rgb.r = 1.0;
				ap_rgb.g = 1.0;
				ap_rgb.b = 1.0;
				ap_rgb = vec3(c2,c3,c1) * u_mix1;  // mix


				vec3 hsl = rgb2hsv(ap_rgb); // hue knob
				hsl[0] += u_hue1;
				if(hsl[0] > 1.0){ hsl[0] =  hsl[0] - floor(hsl[0]); }

				ap_rgb = hsv2rgb(hsl); // output
				//ap_rgb = vec3(random) * u_mix1; // output

				//-----------------------------------------
				// Cross hatch

				//#INCLUDESHADERS

				rgb_2 = hsv2rgb(hsl); // output
				//rgb_2 = vec3(1.0) * u_mix2; // output

				//-----------------------------------------
				// Blend Mix

				if(u_direction > 0.0){
					vec3 swap = (rgb_2);
					rgb_2 = (ap_rgb);
					ap_rgb = (swap);
				}
				
				ap_rgb = blend(ap_rgb, rgb_2, u_blend);

				//-----------------------------------------
				// Post FX

 				// hue knob
				hsl = rgb2hsv(ap_rgb);

				// saturation
				hsl[1] = hsl[1] * u_saturation;

				// thresholds
				float tt = u_thresholdMax;
				if(tt == 1.0){tt = 0.0;}
				if(hsl[0] > 1.0){ hsl[0] =  hsl[0] - floor(hsl[0]); }
				if(tt > u_thresholdMin && (hsl[2] > tt || hsl[2] < u_thresholdMin)){
					discard;
				}

				// whitesparkle
				float target = hsl[0] + u_wshue;
				if(target > 1.0){ target =  target- floor(target); }
				if(target < 0.05){
					if(random > (0.8 + ((1.0 - u_wsparkle) * 0.3) )){
						hsl[2] = 1.0;
					}
				}
				hsl[0] += u_hue;
				if(hsl[0] > 1.0){ hsl[0] =  hsl[0] - floor(hsl[0]); }


				ap_rgb = hsv2rgb(hsl);

				// smooth
				// ap_rgb = blend(ap_rgb, ap_lastRgb, 1.0) * u_smooth;

				// bDif = Utils.mix(lastB, b, _mix);

				// ((a*(mix)+b*mix));

				//ap_rgb.r = mixT(ap_rgb.r, ap_lastRgb.r, u_smooth );
				//ap_rgb.g = mixT(ap_rgb.g, ap_lastRgb.g, u_smooth );
				//ap_rgb.b = mixT(ap_rgb.b, ap_lastRgb.b, u_smooth );


				//-----------------------------------------
				// Output


				//ap_rgb = min(ap_rgb, vec3(0.8));
				//rgb_2 = min(rgb_2, vec3(0.8));

				//mainmix = min(mainmix, vec3(0.8));

				gl_FragColor = vec4(ap_rgb, 1.0);
			}

		</script>
		<!---------------------------------------------------------------------------------------------- -->
		<script type="x-shader/x-vertex" id="node_vertexshader">
			uniform float u_pointSize;
			attribute float a_geoX;
			attribute float a_geoY;
			attribute float a_index;
			varying float v_geoX;
			varying float v_geoY;
			varying float v_index;

			void main() {
				v_geoX = a_geoX;
				v_geoY = a_geoY;
				v_index = a_index;

				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_PointSize = u_pointSize * ( 300.0 / length( mvPosition.xyz ) );
				gl_Position = projectionMatrix * mvPosition;
			}

		</script>

		<script type="x-shader/x-fragment" id="node_fragmentshader">

			uniform sampler2D u_colorMap;
			uniform sampler2D u_texture;

			varying float v_geoX;
			varying float v_geoY;
			varying float v_index;

			void main() {

				//float u_imageSize = simSize.0; // TODO turn into constant
				//float index = (v_index) + 1.0;
				//float x = mod(index, u_imageSize);
				//if(x == 0.0){ x = u_imageSize; }
				//float y = (index - x) / u_imageSize;

				//gl_FragColor = texture2D( u_colorMap, vec2( x / u_imageSize, 1.0 - y / u_imageSize ));


				gl_FragColor = texture2D( u_colorMap, vec2( v_geoX, v_geoY )) * texture2D( u_texture, gl_PointCoord);


				//gl_FragColor = vec4(1.0, 0,0,1.0);
				//gl_FragColor = vec4(v_index * 0.0015, 0,0,1.0);
				//gl_FragColor = vec4(v_geoX, v_geoY,0,1.0);

				//gl_FragColor = texture2D( u_colorMap, gl_PointCoord );
			}
		</script>
		<!---------------------------------------------------------------------------------------------- -->
		
		<script src="js/utils.js"></script>
		<script src="js/datgui.js"></script>
		<script src="js/main.js"></script>
	</body>
</html>
